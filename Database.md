# 1.绪论
## 1.1 数据库系统概述
### 1.1.1 数据库系统的四个基本概念
* 数据
* 数据库
* 数据库管理系统
* 数据库系统

数据库系统由数据库，数据库管理系统，应用系统构成

### 1.1.2 数据管理技术的产生和发展

### 1.1.3 数据库系统特点
* 数据结构化
* 数据共享性能高，冗余度低，容易扩充
* 数据独立性高

## 1.2 数据模型
### 1.2.1 两类数据模型
* 概念数据模型（设计）
* 逻辑（建模）&物理数据模型（实现）

### 1.2.2 概念模型
* 基本概念
    * 实体形：用实体名以及其属性名集合抽象和刻画同类实体，成为实体型。例如学生（学号，姓名，性别，出生年月）是一个实体型
    * 实体集：同类型实体的集合
    * 实体：客观存在并可相互区别的事物称为实体，例如一个学生
    * 属性：实体具有的某一特性称为属性，例如学生姓名
    * 联系：通常指不通实体集之间的联系。有一对一，一对多，多对多联系
    * 码：唯一标识实体的属性成为码，例如学生学号

* 概念模型的表示方法：实体-联系表示法 Entity-Relationship approach

### 1.2.3 数据模型的组成要素
* 数据结构
* 数据操作
* 数据的完整性约束条件

### 1.2.4 常用的数据模型
### 1.2.5 层次模型
### 1.2.6 网状模型
### 1.2.7 关系模型
* 关系模型的数据结构
    * 关系模式 关系名(属性1，属性2...属性n) --实体型，表头，表格描述
    * 关系 --实体集，二维表
    * 元组 --实体，记录，行
    * 属性 --属性，列
    * 域 --属性取值范围
    * 分量 --属性值
    * 码 --码
* 关系模型的数据操作与完整性约束
* 关系模型的优缺点

# 2. 关系型数据库
## 2.1 关系数据结构及形式化定义
### 2.1.1 关系
* 域：域是一种具有相同数据类型的值的集合
* 笛卡尔积：笛卡尔积是域上的一种集合运算
* 关系：D1*D2*D3的自己叫做在域D1,D2...Dn上的关系，表示为R(D1,D2...Dn)，R是关系的名称，n是关系的目或者度。
n=1时，称作一元关系；n=2时称作二元关系。
* 候选码：如果某一属性组的值可以唯一的标识一个元组，而其子集不能，则称该属性组为候选码。候选码的当中的所有属性成为主属性，
不包含在任何候选码当中的属性成为非主属性

### 2.1.2 关系模式
关系的描述成为关系模式，可以表示为R(U,D,DOM,F)
* R：关系名
* U：属性名集合
* D：属性来自的域
* DOM：属性向域的映像集合
* F：属性间数据的依赖关系集合
关系模式可以简记为R(U)

## 2.2 关系操作
### 2.2.1 基本的关系操作
* 查询
    * 选择
    * 投影
    * 连接
    * 除
    * 并
    * 交
    * 差
    * 笛卡尔积
* 增删改
关系操作的特点：操作的对象以及结果都是集合。

### 2.2.2 关系数据库语言的分类

## 2.3 关系的完整性
### 2.3.1 实体完整性
基本关系R的主属性不能为空值

### 2.3.2 参照完整性
倘若F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中的每个元组在F上的值，或者取空值，或者等于S中某个元素的主码值

### 2.3.3 用户定义完整性

## 2.4 关系代数
* 传统集合运算：传统集合运算是一种二目运算，行运算
    * 并
    * 交
    * 差
    * 笛卡尔积
* 专门关系运算：
    * 选择
    * 投影
    * 连接
    * 除

# 6 关系数据理论
## 6.1 问题的提出
数据依赖：
* 函数依赖
* 多值依赖

关系型数据库存在的问题
* 数据冗余
* 更新异常
* 插入异常
* 删除异常

## 6.2 规范化
### 6.2.1 函数依赖
* 关系模式R(U)，X、Y是U真子集，对于R(U)上任意一个关系r，r中不存在两个元组在X上属性值相等且Y上属性值不想等，则称Y函数依赖于X，记作X->Y
* 非平凡函数依赖：X->Y且Y不属于X
* 平凡函数依赖：X->Y且Y属于X(必然成立，不做考虑)
* 若X->Y，对于X的真子集X'，所有X'!->Y，则称Y对X完全函数依赖X->Y(f)
* 若X->Y，对于X的真子集X'，存在X'->Y，则称Y对X部分函数依赖X->Y(p)
* 若X->Y，Y!->X，Y->Z，则称Z对X传递函数依赖X->Y(t)

### 6.2.2 码
* 设K为R(U,F)当中的属性组合，K->U(f)，则K为R的候选码。
* 候选码可以有多个，其中任意一个作为主码
* 候选码当中的所有属性均为主属性。不在候选码当中的属性称为非主属性

### 6.2.3 范式
* 1NF：每一个分量必须是不可拆分的数据项。
* 一个满足低级范式的关系模式，通过模式分解转换为若干个满足高级范式的关系模式的集合，成为规范化

### 6.2.4 2NF
* 若关系模式R满足第一范式，任意一个非主属性完全依赖于任意一个候选码，则称R满足第二范式

### 6.2.5 3NF
* 若关系模式R满足第一范式，若不存在码X，属性组Y，非主属性Z，使得X->Y,Y!->X,Y->Z,则称R满足第三范式

### 6.2.6 BCNF
* 若关系模式R满足第一范式，若X->Y，X必含有码，则称R满足BCNF
* 满足BCNF的关系模式R，每一个决定因素都包含码

### 6.2.7 多值依赖
* 关系模式R(U)，X、Y、Z是U子集，Z=U-X-Y。当R(U)的任意关系r，对给定的(x,z)值有一组Y值与之对应，Y的取值仅与x相关与z无关，则称关系模式R(U)中多值依赖X-->Y成立
* 平凡多值依赖：若Z为空集，则对于关系模式R(X,Y)，如果有X-->Y，则称X-->Y为平凡多值依赖。
* 多值依赖性质：
    * 多值依赖对称性：U=X+Y+Z，若X-->Y则X-->Z
    * 多值依赖传递性：若X-->Y,Y-->Z则X-->Z-Y
    * 函数依赖是多值依赖的一种特殊场景

### 6.2.8 4FN
* 若关系模式R满足第一范式，对于R的每个非平凡多值依赖X-->Y，X都含有码，则称R满足4FN
* 第四范式不允许关系模式当中还有非平凡且非函数依赖的多值依赖

## 6.3 armstrong公理系统
关系模式R(U,F)，F依赖函数集{AB->C,B->D,BC->E}
* 逻辑蕴涵：F逻辑蕴涵AB->C
* 闭包：F所逻辑蕴涵的函数依赖的全体，记作F+
* 最小覆盖
    * 函数依赖右侧仅含有一个属性
    * F中不存在X->A，使得F-{X->A}与F等价
    * F中不存在X->A，使得F-{X->A}并{Z->A}与F等价

## 6.4 模式分解
### 6.4.1 模式分解的定义
### 6.4.2 无损连接性(数据可恢复)和保持函数依赖性


### 6.4.3 模式分解算法
* 无损连接性+保持函数依赖性可达到3FN，可能达到BCNF
* 无损连接可达到4FN

# 7 数据库设计
## 7.1 数据库设计概述
### 7.1.1 数据库设计特点
### 7.1.2 数据库设计方法
* ER
* 3范式
* UML
### 7.1.3 数据库设计步骤
* 需求分析
* 概念结构设计
* 逻辑结构设计
* 物理结构设计
* 数据库实施
* 数据库运行和维护

## 7.2 需求分析

## 7.3 概念结构设计
### 7.3.1 概念模型
### 7.3.2 E-R模型
### 7.3.4 UML

## 7.4 逻辑结构设计
### 7.4.1 E-R图向关系模型转换
* 一个实体型转换为一个关系模式
* 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并
* 一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应关系模式合并
* 一个m:n联系转换为一个关系模式
* 三个或三个以上实体间的多元联系可以转换为一个关系模式
* 具有相同码的关系模式可以合并

### 7.4.2 数据模型的优化
* 并不是规范化程度越高的关系就越优。偏查询操作的关系可以适当降低规范化程度，偏增删改的适合较高的规范化程度

## 7.5 物理结构设计
### 7.5.1 数据库物理设计的内容和方法
### 7.5.2 关系模式存取方法选择
* B+树索引
* hash索引
* 聚簇索引

# 9 关系查询处理和查询优化
## 9.1 关系数据库系统的查询处理
* 查询分析：SQL词法语法检查
* 查询检查：语义分析，符号名转换，安全性检查，完整性初步检查，生成基础查询树
* 查询优化：代数优化，物理优化，生成执行计划
* 查询执行：依据执行计划生成执行代码

## 9.2 关系数据库系统的查询优化
## 9.3 代数优化
* 优先选择运算
* 投影和选择同时进行
* 把投影与前后的双目运算结合
* 选择+笛卡尔积合并为连接运算
* 找出公共子表达式。将子表达式结果写入中间文件。

## 9.4 物理优化
* 代价估算统计信息
    * 表：元组数量，元组长度，占用块数量，溢出块数量
    * 列：不同值个数，最大值，最小值，索引
    * 索引：层数，索引值个数，索引选择基数(多少个元组具有相同索引值)，索引叶节点数

# 10 数据库恢复技术
## 10.1 事务的基本概念 ACID
## 10.2 数据库恢复概述
## 10.3 故障种类
* 事务内部故障：运算溢出，死锁撤销事务，违反完整性约束等。恢复操作：事务撤消(UNDO)
* 系统故障：硬件错误，断电，操作系统故障等，缓冲区内容丢失。UNDO未完成事物，REDO已提交事务
* 介质故障：磁盘损坏
* 病毒

## 10.4 恢复实现技术
### 10.4.1 数据转储
### 10.4.2 登记日志文件

## 10.5 恢复策略
### 10.5.1 事务故障恢复
* UNDO日志：记录日志的流程：写操作日志(旧值)，写磁盘，COMMIT/ABORT。如果已经COMMIT说明已经完成，ABORT不能说明完成。恢复未提交事务对磁盘的影响，造成数据的不一致。逆向读取日志进行恢复，直到检查点。
* REDO日志：记录日志的流程：写操作日志(新值)，COMMIT/ABORT，写磁盘。如果已经COMMIT说明已经完成，ABORT不能说明完成。重做COMMIT事务，忽略ABORT。从日志起始位置(检查点)处理每一条记录。
* UNDO/REDO日志：写操作日志(新旧值都保存)，写磁盘和COMMIT操作可以交换。正向重做已提交事务，撤销所有未完成修改。
* 检查点
    * 静态检查点 周期性设置，需要停止接受新的事务
    * 非静止检查点
* 转储点 恢复介质故障

### 10.5.2 系统故障恢复
* 正向扫描日志文件，已提交的进入REDO队列，未完成的进入UNDO队列
* 未完成进行UNDO处理
* 已提交的进行REDO处理
### 10.5.3 介质故障恢复

## 10.6 具有检查点的恢复技术

# 11 并发控制
## 11.1 并发控制概述
事务是并发控制的基本单位。

并发操作带来的数据不一致包括：
* 丢失修改
* 脏读
* 不可重复读(幻读)

并发控制的技术有：
* 封锁
* 时间戳
* 多版本并发控制

## 11.2 封锁
* 排他锁 X锁
* 共享锁 S锁

## 11.3 封锁协议
* 一阶段封锁协议：T事务在修改数据前添加X锁，事务结束时释放。可以防止丢失修改
* 二阶段封锁协议：在一阶段封锁协议基础之上，增加读取数据前加S锁，读取完毕后立即释放S锁。可以防止读取脏数据。
* 三阶段封锁协议：在二阶段封锁协议基础之上，在事务结束时释放S锁。可以防止不可重复读。

## 11.4 死锁
* 死锁的预防(不适合数据库管理系统)
    * 一次封锁法：将所有的加锁操作转化成一次原子操作。问题1：降低并发度 2：无法实现判断事务当中可能出现的所有的锁
    * 顺序封锁法：从根至叶子节点逐级加锁。问题1：数据库封锁的数据对象多，增删变化快，难以维护
* 死锁的诊断与解除(检测后采取措施：撤销死锁代价较小的事务)
    * 超时法：粗暴，可能会有误判
    * 等待图法：事务等待图当中是否存在回路进行检测。

## 11.5 并发调度可串行性
### 11.5.1 可串行化调度
多个事务并发执行的结果，与按某一顺序串行这些事务相同，则称这种调度策略为可串行化调度。

### 11.5.2 冲突可串行化调度(可串行化调度的充分不必要条件)
冲突操作：对同一数据的读写/写写操作。两个事务的冲突操作不能交换执行顺序。

一个关于两个事务的调度Sc，如果Sc在保证冲突操作顺序不变的情况下，通过交换其他不冲突操作顺序得到一个串行化调度，则称Sc为冲突可串行化调度。

## 11.6 两阶段封锁协议(用于产生可串行化调度，可串行化调度的充分不必要条件)
* 阶段一获得封锁
* 阶段二释放封锁

## 11.7 封锁的粒度
* 封锁对象划分
    * 逻辑单元 属性值，属性值集合，元组，关系，索引项，整个索引
    * 物理单元：页(数据页，索引页)，物理记录
* 封锁粒度越大：开销少，并发程度少
* 封锁粒度越小：开销大，并发程度大

### 11.7.1 多粒度封锁
对一个节点加锁，意味着对这个节点的所有后裔节点加锁

### 11.7.2 意向锁(多粒度封锁需要检查节点的上下级封锁冲突，效率低，引入意向锁)
对任意节点(元组)加锁时，需要首先对其上层节点(关系)加意向锁

## 11.8 其他并发控制机制
### 11.8.1 多版本并发控制
数据对象A相关联的两个事务，T1写事务，T2读事务。T1写事务发生时为A生成一个新的版本A'，T2事务在A'(修改后的A)上继续进行，T1提交后，T2再进行提交。
优势：消除了对象读写冲突，提高系统性能。

### 11.8.2 改进的多版本并发控制 MV2PL
* 只读事务：多版本时间戳
* 更新事务：两阶段封锁

验证锁的引入：读写锁可以兼容，验证锁与所有锁互斥。读锁在旧值上继续运行，写事务在提交前获得验证锁，等待读锁释放，获得验证锁，丢弃对象旧值，代之与新版本。



